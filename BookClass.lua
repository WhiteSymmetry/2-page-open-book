---------------------------------------------------------------------------------------------	Two Page Open Book---------------------------------------------------------------------------------------------[[Class:			BookClassPurpose:		Two page open book display. Implements page turning in both directionsDescription:	Along with a book definition class, such as MyBook.lua, a fully featured				2-page open book can be displayed anywhere in the device display. 				The class supports any page dimensions as long as all the pages have the same				dimensions. If different page sizes are used the results may not be desirable.				The page can be turned by touching and draggin, or by touching and releasing 				anywhere in the page. Author:			Dan GoldmanHistory:		Date			By			Modification				March 2012		Dan Goldman	Initial creation								--]]--[[Copyright (C) 2012 Dan Goldman. All Rights ReservedPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The Software may only be sold as part of a greater software program or application where itconstitutes less than 50% of the total functionality. The Software may not be sold as isas a separate stand-alone software program or application. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Published changes made to this software and associated documentation and module files (the"Software") may be used and distributed by Dan Goldman or parties assigned by him without notification. Modifications made to this software and associated documentation and module files may or may not become part of an official software release. All modifications made to the software will be licensed under these same terms and conditions.--]]local BookClass = {}function BookClass:new (pageHeight, pageWidth, bookStartX, bookStartY, numPages)	local newBook = {		pageHeight = pageHeight or 0,		pageWidth = pageWidth or 0,		bookStartX = bookStartX or 0,		bookStartY = bookStartY or 0, 		numPages = numPages or 0,		bookEndX = bookStartX + pageWidth*2 - 1,		bookEndY = bookStartY + pageHeight - 1,		leftPageStartX = bookStartX,		leftPageEndX = bookStartX + pageWidth - 1,		rightPageStartX = bookStartX + pageWidth,		rightPageEndX = bookStartX + pageWidth*2 - 1,			}		setmetatable(newBook, self) 	self.__index = self	return newBookend----	Globals--	local book = {}local TURNSPEEDif Model == "Nook" then	TURNSPEED = 80	-- Need to speed it up as the Nook is very slowelse		TURNSPEED = 40end	local bookGrouplocal leftPageLeft				-- The hidden page to the left of the left pagelocal leftPage					-- The left pagelocal leftPageBelow				-- The page immediately below the left pagelocal rightPage					-- The right page local rightPageRight			-- The hidden page to the right of the right pagelocal rightPageBelow			-- The page immediately below the right pagelocal curlShadowlocal trailingShadowlocal leadingShadowlocal leadingShadowMasklocal pageMasklocal currentPagelocal lastPagelocal touchXlocal relativeTouchXlocal isDraglocal turnDirectionlocal bookLoopThreadlocal isTurninglocal function orderPages (turnDirection)	if turnDirection == "Left" then		if leftPageLeft ~= nil then			bookGroup:insert (leftPageLeft)		end		if leftPageBelow ~= nil then			bookGroup:insert (leftPageBelow)		end				bookGroup:insert (leftPage)		leftPage:setMask (pageMask)		leftPage.maskX = book.pageWidth/2		leftPage.isHitTestMasked = false				bookGroup:insert (rightPageBelow)		rightPageBelow.isVisible = true				bookGroup:insert (rightPage)		rightPage:setMask (pageMask)		rightPage.maskX = book.pageWidth/2		-- Set the mask to the right edge of the page - the full page should be displayed		rightPage.isHitTestMasked = false				bookGroup:insert (rightPageRight)		rightPageRight.isVisible = true		rightPageRight:setMask (pageMask)		rightPageRight.maskX = -book.pageWidth/2		-- Set the mask to the left edge of the page - the entire page should be masked		leadingShadow.rotation = 0 -- default		leadingShadow.maskX = 1		bookGroup:insert (leadingShadow)				trailingShadow.rotation = 0		bookGroup:insert (trailingShadow)				curlShadow.rotation = 0		bookGroup:insert (curlShadow)					elseif turnDirection == "Right" then		if rightPageRight ~= nil then			bookGroup:insert (rightPageRight)		end		if rightPageBelow ~= nil then			bookGroup:insert (rightPageBelow)		end		bookGroup:insert (rightPage)		rightPage:setMask (reversePageMask)		rightPage.maskX = -book.pageWidth/2		rightPage.isHitTestMasked = false				bookGroup:insert (leftPageBelow)		leftPageBelow.isVisible = true		bookGroup:insert (leftPage)		leftPage:setMask (reversePageMask)		leftPage.isHitTestMasked = false		bookGroup:insert (leftPageLeft)		leftPageLeft.isVisible = true		leftPageLeft:setMask (reversePageMask)		leftPageLeft.maskX = -book.pageWidth/2		leadingShadow.rotation = 180 -- reverse		leadingShadow.maskX = 2		bookGroup:insert (leadingShadow)				trailingShadow.rotation = 180 -- reverse		bookGroup:insert (trailingShadow)		curlShadow.rotation = 180 -- reverse		bookGroup:insert (curlShadow)			end	endlocal function pageTouch (self, event)	local phase = event.phase	touchX = event.x	stopAudio() -- Immediately stop playing any sound effects if the page is touched.	--	If the page is already turing and the display is touched handle gracefully.--	No need to modify listeners or re-order the pages. Just set the parameters to--	indicate manual dragging and restore the focus to the page.	if isTurning and phase == "began" then		isDrag = true		isTurning = false		display.getCurrentStage():setFocus( self )		self.isFocus = true			return true	end		if phase == "began" then		display.getCurrentStage():setFocus( self )  -- Need this in case touched removed when off screen		self.isFocus = true		isDrag = true		isTurning = false		if event.target.pageID == "Left" then			turnDirection = "Right"			rightPage:removeEventListener( "touch", rightPage )		elseif event.target.pageID == "Right" then			turnDirection = "Left"			leftPage:removeEventListener( "touch", leftPage )		else			print ("ERROR: pageTouch - invalid pageID: ", event.target.pageNo)		end		orderPages (turnDirection)	elseif self.isFocus and phase == "ended" then -- Need to check if phase was ended before setting the focus to nil		display.getCurrentStage():setFocus( nil )		self.isFocus = nil	end	if phase == "ended" or phase == "cancelled" then		isDrag = false	end	return trueendlocal function turnPageLeft()	local startScaleFactor	if isDrag == false then		isTurning = true		touchX = touchX - TURNSPEED -- Auto turn forward	end	local relativeTouchX = touchX - book.bookStartX <= book.pageWidth*2		and touchX - book.bookStartX		or book.pageWidth*2-1	local pageDelta = book.bookEndX - touchX		rightPage.maskX = book.pageWidth / 2 - pageDelta		rightPageRight.x = (1.5 * book.pageWidth - pageDelta < -book.pageWidth/2) 		and -book.pageWidth/2 		or 1.5 * book.pageWidth - pageDelta	rightPageRight.maskX = -book.pageWidth / 2 + pageDelta/2----	Curl Shadow--	if relativeTouchX >= curlShadow.width then		startScaleFactor = pageDelta / curlShadow.width <= 1 			and pageDelta / curlShadow.width  -- Need to scale from zero to start			or 1			curlShadow.xScale = (1 - (relativeTouchX / (book.pageWidth*2))/2) * startScaleFactor > 0 			and (1 - (relativeTouchX / (book.pageWidth*2))/2) * startScaleFactor			or 0.0001	else		curlShadow.xScale = (relativeTouchX / curlShadow.width) > 0			and relativeTouchX / curlShadow.width or 0.0001	end	curlShadow.x = (book.pageWidth - curlShadow.contentWidth/2 - pageDelta/2) >= -curlShadow.contentWidth/2		and book.pageWidth - curlShadow.contentWidth/2 - pageDelta/2 or -curlShadow.contentWidth/2	----	Right Page Shadow--	if relativeTouchX >= trailingShadow.width then		startScaleFactor = pageDelta / trailingShadow.width <= 1 			and pageDelta / trailingShadow.width  -- Need to scale from zero to start			or 1		trailingShadow.xScale = (1 - (relativeTouchX / (book.pageWidth*2))/3) * startScaleFactor > 0 			and (1 - (relativeTouchX / (book.pageWidth*2))/3) * startScaleFactor			or 0.0001 -- grow the shadow	else		trailingShadow.xScale = (relativeTouchX / trailingShadow.width) > 0			and relativeTouchX / trailingShadow.width or 0.0001 -- scale back to zero	end		trailingShadow.x = (book.pageWidth + trailingShadow.contentWidth/2 - pageDelta/2) >= trailingShadow.contentWidth/2		and book.pageWidth + trailingShadow.contentWidth/2 - pageDelta/2 or trailingShadow.contentWidth/2----	Left page shadow--	if relativeTouchX >= leadingShadow.width/2 then			startScaleFactor = pageDelta / leadingShadow.width <= 1 			and pageDelta / leadingShadow.width  -- Need to scale from zero to start			or 1		leadingShadow.xScale = (1 - (relativeTouchX / (book.pageWidth*2))/2) * startScaleFactor > 0			and (1 - (relativeTouchX / (book.pageWidth*2))/2)			or 0.0001	-- grow the shadow	else		leadingShadow.xScale = (relativeTouchX / leadingShadow.contentWidth/2) > 0			and relativeTouchX / (leadingShadow.width/2) or 0.0001 -- scale back to zero			end	leadingShadow.x = relativeTouchX - book.pageWidth + 1	if isDrag == false and touchX >= book.bookEndX then -- page turned back		touchX = book.bookEndX		coroutine.resume (bookLoopThread, false)		turnDirection = nil		isTurning = false		return true		end		if isDrag == false and touchX <= book.bookStartX then -- page turned all the way--	Exit page turn, reset book for the next page turn		lastPage = currentPage		currentPage = currentPage+2		touchX = book.bookStartX		coroutine.resume (bookLoopThread, false)		turnDirection = nil		isTurning = false		return true	endendlocal function turnPageRight()	local startScaleFactor		if isDrag == false then		isTurning = true		touchX = touchX + TURNSPEED -- Auto turn	end	local relativeTouchX = touchX - book.bookStartX > 0		and touchX - book.bookStartX		or 0	local pageDelta = touchX - book.bookStartX	leftPage.maskX = -book.pageWidth/2 + pageDelta	leftPageLeft.x = (-1.5*book.pageWidth + pageDelta > book.pageWidth/2) 		and book.pageWidth/2		or -1.5*book.pageWidth + pageDelta	leftPageLeft.maskX = book.pageWidth / 2 - pageDelta/2----	Curl Shadow--	if book.bookEndX - touchX >= curlShadow.width then		startScaleFactor = (pageDelta) / curlShadow.width <= 1 			and pageDelta / curlShadow.width  -- Need to scale from zero to start			or 1			curlShadow.xScale = (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/2) * startScaleFactor >  0			and (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/2) * startScaleFactor 			or 0.0001	else		curlShadow.xScale = ((book.bookEndX - touchX) / curlShadow.width) > 0			and (book.bookEndX - touchX) / curlShadow.width or 0.0001	end	curlShadow.x = (-book.pageWidth + curlShadow.contentWidth/2 + pageDelta/2) <= curlShadow.contentWidth/2		and -book.pageWidth + curlShadow.contentWidth/2 + pageDelta/2 or curlShadow.contentWidth/2--	Left Page Shadow--	if book.bookEndX - touchX >= trailingShadow.width then		startScaleFactor = (pageDelta) / trailingShadow.width <= 1 			and pageDelta / trailingShadow.width  -- Need to scale from zero to start			or 1		trailingShadow.xScale = (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/3) * startScaleFactor > 0 			and (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/3) * startScaleFactor			or 0.0001 -- grow the shadow	else		trailingShadow.xScale = ((book.bookEndX - touchX) / trailingShadow.width) > 0			and (book.bookEndX - touchX) / trailingShadow.width or 0.0001 -- scale back to zero	end		trailingShadow.x = (-book.pageWidth - trailingShadow.contentWidth/2 + pageDelta/2) <= -trailingShadow.contentWidth/2		and -book.pageWidth - trailingShadow.contentWidth/2 + pageDelta/2 or -trailingShadow.contentWidth/2----	Right page shadow--	if book.bookEndX - touchX >= leadingShadow.width/2 then			startScaleFactor = (pageDelta) / leadingShadow.width <= 1 			and pageDelta / leadingShadow.width  -- Need to scale from zero to start			or 1		leadingShadow.xScale = (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/2) * startScaleFactor > 0			and (1 - ((book.bookEndX - touchX) / (book.pageWidth*2))/2)			or 0.0001	-- grow the shadow	else		leadingShadow.xScale = ((book.bookEndX - touchX) / leadingShadow.width/2) > 0			and (book.bookEndX - touchX) / (leadingShadow.width/2) or 0.0001 -- scale back to zero			end	leadingShadow.x = relativeTouchX - book.pageWidth + 1	if isDrag == false and touchX <= book.bookStartX then -- Page turned back--	Exit page turn, reset book for the next page turn		touchX = book.bookStartX		coroutine.resume (bookLoopThread, false)		turnDirection = nil		isTurning = false		return true	end	if isDrag == false and touchX >= book.bookEndX then--	Exit page turn, reset book for the next page turn		lastPage = currentPage		currentPage = currentPage-2		touchX = book.bookEndX		coroutine.resume (bookLoopThread, false)		turnDirection = nil		isTurning = false		return true	endendlocal function turnPageListener (event)	if turnDirection == "Left" then		turnPageLeft()	elseif turnDirection == "Right" then		turnPageRight()	endendlocal function positionPages(currentPage)	if currentPage > lastPage and currentPage < book.numPages then -- Just turned the page forward (to the left)			leftPageBelow = leftPage		leftPageBelow.isVisible = false		leftPageLeft = rightPage		leftPageLeft.x = -book.pageWidth/2		leftPageLeft.isVisible = false				leftPage = rightPageRight		leftPage.pageID = "Left"		leftPage:setMask (nil)				rightPage = rightPageBelow		rightPage.pageID = "Right"		rightPage:setMask (nil)				if currentPage < (book.numPages-1) then		-- There are at leaset 2 more pages to the right			rightPageBelow = display.newImageRect(book.page[currentPage+3].image, book.page[currentPage+3].width, book.page[currentPage+3].height)			rightPageBelow.x, rightPageBelow.y = book.pageWidth/2, 0	-- Set with respect to containing group			rightPageBelow.isVisible = false					rightPageRight = display.newImageRect(book.page[currentPage+2].image, book.page[currentPage+2].width, book.page[currentPage+2].height)			rightPageRight.x, rightPageRight.y = 1.5 * book.pageWidth, 0			rightPageRight.isVisible = false		end		end			if currentPage < lastPage then			rightPageBelow = rightPage		rightPageBelow.isVisible = false				rightPageRight = leftPage		rightPageRight.isVisible = false				leftPage = leftPageBelow		leftPage.pageID = "Left"		leftPage:setMask (nil)				rightPage = leftPageLeft		rightPage.pageID = "Right"		rightPage:setMask (nil)				if currentPage > 1 then -- Load the left pages					leftPageBelow = display.newImageRect(book.page[currentPage-2].image, book.page[currentPage+2].width, book.page[currentPage+2].height)			leftPageBelow.x, leftPageBelow.y = -book.pageWidth/2, 0	-- Set with respect to containing group			leftPageBelow.isVisible = false					leftPageLeft = display.newImageRect(book.page[currentPage-1].image, book.page[currentPage-1].width, book.page[currentPage-1].height)			leftPageLeft.x, leftPageLeft.y = -1.5 * book.pageWidth, 0			leftPageLeft.isVisible = false		end	endendlocal function bookLoop()	local screenExit = false	--	Initialize the book - display pages 1 and 2	leftPage = display.newImageRect(book.page[1].image, book.page[1].width, book.page[1].height)	bookGroup:insert (leftPage)	leftPage.x, leftPage.y = -book.pageWidth/2, 0	-- Set with respect to containing group	leftPage.isVisible = true		leftPage.pageID = "Left"	rightPage = display.newImageRect(book.page[2].image, book.page[2].width, book.page[2].height)	bookGroup:insert (rightPage)	rightPage.x, rightPage.y = book.pageWidth/2, 0	-- Set with respect to containing group	rightPage.isVisible = true	rightPage.pageID = "Right"		rightPageBelow = display.newImageRect(book.page[4].image, book.page[4].width, book.page[4].height)	rightPageBelow.x, rightPageBelow.y = book.pageWidth/2, 0	-- Set with respect to containing group	rightPageBelow.isVisible = false	rightPageRight = display.newImageRect(book.page[3].image, book.page[3].width, book.page[3].height)	rightPageRight.x, rightPageRight.y = 1.5 * book.pageWidth, 0	rightPageRight.isVisible = false	---- Listeners--	Runtime:addEventListener( "enterFrame", turnPageListener )			repeat		if saveCurrentPage ~= currentPage then			positionPages(currentPage)		end		--	Play audio clip if there is one. Audio files are always expected to be associated with the current (odd/left) page--	never with the even/right page.		if book.page[currentPage].audioTrack then			playSoundEffect	(book.page[currentPage].audioTrack)			end				if currentPage < book.numPages -1 then			rightPage.touch = pageTouch			rightPage:addEventListener( "touch", rightPage )		end		if currentPage > 1 then			leftPage.touch = pageTouch			leftPage:addEventListener( "touch", leftPage )		end			saveCurrentPage = currentPage				screenExit = coroutine.yield()		rightPage:removeEventListener( "touch", rightPage )		leftPage:removeEventListener( "touch", leftPage )			until screenExit == true	Runtime:removeEventListener("enterFrame", turnPageListener)endfunction BookClass:run ()		bookLoopThread = coroutine.create (bookLoop)	coroutine.resume (bookLoopThread)endfunction BookClass:close()--	book = nil--	bookGroup = nil	coroutine.resume (bookLoopThread, true) -- Cause book to exit gracefullyendfunction BookClass:setUp (bookObject)	book = bookObject	bookGroup = nil	leftPageLeft = nil			-- The hidden page to the left of the left page	leftPage = nil				-- The left page	leftPageBelow = nil			-- The page immediately below the left page	rightPage = nil				-- The right page 	rightPageRight = nil		-- The hidden page to the right of the right page	rightPageBelow	= nil		-- The page immediately below the right page	curlShadow = nil	trailingShadow = nil	leadingShadow = nil	leadingShadowMask =nil	pageMask = nil	bookLoopThread = nil	currentPage = 1	saveCurrentPage = currentPage	lastPage = 0	touchX = book.bookEndX	relativeTouchX = book.pageWidth*2	isDrag = false	turnDirection = nil	isTurning = false		bookGroup = display.newGroup()	bookGroup.x, bookGroup.y = book.bookStartX + book.pageWidth, book.bookStartY + book.pageHeight/2		curlShadow = display.newImageRect("curl_shadow.png", 128, 4)	curlShadow.x = book.pageWidth + curlShadow.contentWidth/2	curlShadow.y = 0	curlShadow.yScale = book.pageHeight / curlShadow.contentHeight	curlShadow.xScale = 0.0001	curlShadow.isVisible = true		trailingShadow = display.newImage("trailing_shadow.png")	trailingShadow.y = 0	trailingShadow.yScale = book.pageHeight / trailingShadow.contentHeight	trailingShadow.xScale = 0.0001	trailingShadow.isVisible = true		leadingShadow = display.newImage("leading_shadow.png")	leadingShadow.y = 0	leadingShadow.yScale = book.pageHeight / leadingShadow.contentHeight	leadingShadow.xScale = 0.0001	leadingShadow.isVisible = true		leadingShadowMask = graphics.newMask ("page_mask.png")	leadingShadow:setMask (leadingShadowMask)	leadingShadow.maskX = 1		pageMask = graphics.newMask ("page_mask.png")	reversePageMask = graphics.newMask ("page_mask_reverse.png")			return bookGroup	endreturn BookClass